// Generated by jextract

package jdk.internal.include.sys;

import jdk.internal.include.common.CaptureCallStateUtil;
import jdk.internal.include.common.RuntimeHelper;

import java.lang.foreign.MemorySegment;
import java.lang.foreign.SegmentScope;
import java.lang.foreign.ValueLayout;
import java.lang.invoke.MethodHandle;
import java.lang.invoke.VarHandle;

import static jdk.internal.include.common.Util.shouldNotReachHere;

public final class SocketH {

    public static int SAE_ASSOCID_ANY() {
        return socket_h.SAE_ASSOCID_ANY();
    }
    public static int SAE_CONNID_ANY() {
        return socket_h.SAE_CONNID_ANY();
    }

    public static ValueLayout socklen_t() {
        return socket_h.socklen_t;
    }
    /**
     * Connects the socket referred to by the
     * file descriptor sockfd to the address specified by addr.  The
     * addrlen argument specifies the size of addr.  The format of the
     * address in addr is determined by the address space of the socket
     * sockfd;
     *
     * {@snippet :
     * int connect(int, struct sockaddr*, socklen_t);
     *}
     *
     * @param sockfd the socket file descriptor.
     * @param addr   points to a sockaddr structure in
     *               which the sending address is to be stored. The length
     *               and format of the address depend on the address
     *               family of the socket.
     * @param addlen the length of the supplied sockaddr
     *               structure
     * @return If the connection or binding succeeds, zero is returned.  On
     *        error, -1 is returned, and {@code errno} is set to indicate the error.
     * @see <a href="https://man7.org/linux/man-pages/man2/connect.2.html">connect</a> for further details.
     */
    @Deprecated(forRemoval = true)
    public static int connect(int sockfd, MemorySegment addr, int addlen) {
        throw new UnsupportedOperationException();
/*        var mh$ = connect$MH();
        try {
            return (int)mh$.invokeExact(sockfd, addr, addlen);
        } catch (Throwable ex$) {
            throw shouldNotReachHere(ex$);
        }*/
    }

    /**
     * Connects the socket referred to by the
     * file descriptor sockfd to the address specified by addr.  The
     * addrlen argument specifies the size of addr.  The format of the
     * address in addr is determined by the address space of the socket
     * sockfd;
     *
     * {@snippet :
     * int connect(int, struct sockaddr*, socklen_t);
     *}
     *
     * @param sockfd the socket file descriptor.
     * @param addr   points to a sockaddr structure in
     *               which the sending address is to be stored. The length
     *               and format of the address depend on the address
     *               family of the socket.
     * @param addlen the length of the supplied sockaddr
     *               structure
     * @param errCap the segment to use for capturing errCap
     * @return If the connection or binding succeeds, zero is returned.  On
     *         error, -1 is returned, and {@code errno} is set to indicate the error.
     * @see <a href="https://man7.org/linux/man-pages/man2/connect.2.html">connect</a> for further details.
     */
    public static int connect(int sockfd, MemorySegment addr, int addlen, MemorySegment errCap) {
        try {
            return (int) CONNECT_MH.invokeExact(sockfd, addr, addlen, errCap);
        } catch (Throwable ex$) {
            throw shouldNotReachHere(ex$);
        }
    }


    /**
     * Receives a message from a
     * connection-mode or connectionless-mode socket. It is normally
     * used with connectionless-mode sockets because it permits the
     * application to retrieve the source address of received data.
     *
     * {@snippet :
     * ssize_t recvfrom(int, void*, size_t, int, struct sockaddr*, socklen_t*);
     *}
     * @param socket      the socket file descriptor.
     * @param buffer      points to the buffer where the message should be
     *                    stored.
     * @param length      the length in bytes of the buffer pointed
     *                    to by the buffer argument.
     * @param flags       the type of message reception. Values of
     *                    this argument are formed by logically OR'ing zero or
     *                    more of the following values:
     *                    <ul><li>
     *                    MSG_PEEK    Peeks at an incoming message. The data is
     *                                treated as unread and the next recvfrom()
     *                                or similar function shall still return
     *                                this data.
     *                    </li>
     *                    <li>
     *                    MSG_OOB     Requests out-of-band data. The
     *                                significance and semantics of out-of-band
     *                                data are protocol-specific.
     *                    </li>
     *                    <li>
     *                    MSG_WAITALL On SOCK_STREAM sockets this requests that
     *                                the function block until the full amount
     *                                of data can be returned. The function may
     *                                return the smaller amount of data if the
     *                                socket is a message-based socket, if a
     *                                signal is caught, if the connection is
     *                                terminated, if MSG_PEEK was specified, or
     *                                if an error is pending for the socket.
     *                    </li></ul>
     * @param address     a null pointer, or points to a sockaddr structure in
     *                    which the sending address is to be stored. The length
     *                    and format of the address depend on the address
     *                    family of the socket.
     * @param addressLen  either a null pointer, if address is a null pointer,
     *                    or a pointer to a socklen_t object which on input
     *                    specifies the length of the supplied sockaddr
     *                    structure, and on output specifies the length of the
     *                    stored address.
     * @return the length of the message in bytes. If no messages are available to be received
     *         and the peer has performed an orderly shutdown, returns 0.
     *         Otherwise, -1 is returned and {@code errno} is set to indicate the error.
     * @see <a href="https://man7.org/linux/man-pages/man3/recvfrom.3p.html">recvfrom</a>
     */
    public static long recvfrom(int socket,
                                MemorySegment buffer, long length,
                                int flags,
                                MemorySegment address, MemorySegment addressLen,
                                MemorySegment errCap) {
        try {
            return (long)RECVFROM_MH.invokeExact(socket, buffer, length, flags, address, addressLen, errCap);
        } catch (Throwable ex$) {
            throw shouldNotReachHere(ex$);
        }
    }
    /**
     * Send a message on a socket.
     *
     * {@snippet :
     * ssize_t sendto(int, void*, size_t, int, struct sockaddr*, socklen_t);
     *}
     * @param socket      Specifies the socket file descriptor.
     * @param message     Points to a buffer containing the message to be sent.
     * @param length      Specifies the size of the message in bytes.
     * @param flags       Specifies the type of message transmission. Values of
     *                    this argument are formed by logically OR'ing zero or
     *                    more of the following flags:
     *                    <ul><li>
     *                    MSG_EOR       Terminates a record (if supported by
     *                                  the protocol).
     *                    </li>
     *                    <li>
     *                    MSG_OOB       Sends out-of-band data on sockets that
     *                                  support out-of-band data. The
     *                                  significance and semantics of out-of-
     *                                  band data are protocol-specific.
     *                    </li>
     *                    <li>
     *                    MSG_NOSIGNAL  Requests not to send the SIGPIPE signal
     *                                  if an attempt to send is made on a
     *                                  stream-oriented socket that is no
     *                                  longer connected. The [EPIPE] error
     *                                  shall still be returned.
     *                    </li></ul>
     * @param destAddr   Points to a sockaddr structure containing the
     *                    destination address. The length and format of the
     *                    address depend on the address family of the socket.
     * @param destLen    Specifies the length of the sockaddr structure
     *                    pointed to by the dest_addr argument.
     * @see <a href="https://man7.org/linux/man-pages/man3/sendto.3p.html">sendto</a>
     */
    public static long sendto(int socket,
                              MemorySegment message, long length,
                              int flags,
                              MemorySegment destAddr, int destLen,
                              MemorySegment errCap) {
        try {
            return (long)SENDTO_MH.invokeExact(socket, message, length, flags, destAddr, destLen, errCap);
        } catch (Throwable ex$) {
            throw shouldNotReachHere(ex$);
        }
    }
    /**
     * Disconnects a connection on a socket.
     *
     * {@snippet :
     * int disconnectx(int, sae_associd_t, sae_connid_t);
     *}
     *
     * @param socket      the socket file descriptor.
     * @param associd     the association identifier. Should be set to SAE_ASSOCID_ANY
     * @param connid      the connection identifier. Should be set to SAE_CONNID_ANY
     * @return 0 if successful; otherwise -1 is returned and the global integer variable {@code errno} is set
     *         to indicate the error.
     * @see <a href="https://www.manpagez.com/man/2/disconnectx/">disconnectx</a>
     */
    public static int disconnectx(int socket, int associd, int connid, MemorySegment errCap) {
        try {
            return (int)DISCONNECTX_MH.invokeExact(socket, associd, connid, errCap);
        } catch (Throwable ex$) {
            throw shouldNotReachHere(ex$);
        }
    }

    public static int errno(MemorySegment errCap) {
        return (int) ERRNO_VH.get(errCap);
    }

    public static MemorySegment allocateErrCap() {
        return MemorySegment.allocateNative(ERRNO_CSS_BYTE_SIZE, SegmentScope.auto());
    }
/*
    static MethodHandle connect$MH() {
        return RuntimeHelper.requireNonNull(constants$0.connect$MH,"connect");
    }*/
/*
    static MethodHandle recvfrom$MH() {
        return RuntimeHelper.requireNonNull(constants$0.recvfrom$MH,"recvfrom");
    }
    static MethodHandle sendto$MH() {
        return RuntimeHelper.requireNonNull(constants$0.sendto$MH,"sendto");
    }
    static MethodHandle disconnectx$MH() {
        return RuntimeHelper.requireNonNull(constants$0.disconnectx$MH,"disconnectx");
    }*/

    private static final String ERRNO = "errno";
    private static final MethodHandle CONNECT_MH;
    private static final VarHandle ERRNO_VH;
    private static final long ERRNO_CSS_BYTE_SIZE;
    private static final MethodHandle RECVFROM_MH;
    private static final MethodHandle SENDTO_MH;
    private static final MethodHandle DISCONNECTX_MH;

    static {

        var connectCapture = CaptureCallStateUtil
                .createCapture("connect", constants$0.connect$FUNC, ERRNO);

        CONNECT_MH = connectCapture.methodHandle();
        ERRNO_VH = connectCapture.captureHandle();
        ERRNO_CSS_BYTE_SIZE = connectCapture.ccsByteSize();

        RECVFROM_MH = CaptureCallStateUtil
                .createCapture("recvfrom", constants$0.recvfrom$FUNC, ERRNO)
                .methodHandle();

        SENDTO_MH = CaptureCallStateUtil
                .createCapture("sendto", constants$0.sendto$FUNC, ERRNO)
                .methodHandle();

        DISCONNECTX_MH = CaptureCallStateUtil
                .createCapture("disconnectx", constants$0.disconnectx$FUNC, ERRNO)
                .methodHandle();

    }

    private SocketH() {}
}
